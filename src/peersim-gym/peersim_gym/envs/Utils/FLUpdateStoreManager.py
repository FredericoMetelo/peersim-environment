import uuid
from collections import OrderedDict


class FLUpdateStoreManager:
    """
    This class is responsible for storing the updates generated by the different agents
    """
    def __init__(self, custom_update_size_function):
        self.update_dictionary = {}
        self.updates_done_per_agent = {}
        self.custom_update_size_function = custom_update_size_function

    def store_update(self, agent, src_id, dst_idx, update):
        uuid = self.generate_uuid()
        self.update_dictionary[uuid] = self.create_update_entry(uuid, agent, src_id, dst_idx, update)

        return self.update_dictionary[uuid]

    def generate_uuid(self):
        return str(uuid.uuid4())

    def create_update_entry(self, uuid, agent, src_id, dst_idx, update):
        size = self.get_update_size(update)
        return {"uuid": uuid, "agent": agent, "src_id": src_id, "dst_idx": dst_idx, "update": update, "size": size}

    def get_update_size(self, update):
        """
        This method checks what is the type of the update:
        Supports:
        - a state_dict() of a pytorch model.
        - a list with the gradients of a pytorch model.
        - custom input, as long as a custom function to deal with it was provided.
        :param update:
        :return size:
        """
        if self.custom_update_size_function is not None:

            return self.custom_update_size_function(update)

        # Default strategies:
        if isinstance(update, OrderedDict):
            size = 0
            for key in update.keys():
                size += update[key].numel() * update[key].element_size()
            return size
        # 2. Check if it's a pytorch gradients list, only can accept lists in this mode.
        elif isinstance(update, list):
            size = 0
            for i in range(len(update)):
                size += update[i].numel() * update[i].element_size()
            return size
        else:
            raise ValueError("The update type is not supported, please use pytorch's model.state_grad(), a list of "
                             "tensors. Or provide your own custom function.")


    def set_completed(self, uuid):
        """
        Marks the update with the given uuid as completed
        :param uuid:
        :return:
        """
        update_done = self.get_update(uuid)
        if update_done is not None:
            agent = update_done["agent"]
            if agent in self.updates_done_per_agent:
                self.updates_done_per_agent[agent].append(update_done)
            else:
                self.updates_done_per_agent[agent] = [update_done]

    def get_update(self, uuid):
        """
        Returns the update with the given uuid and removes it from the dictionary
        :param uuid:
        :return:
        """
        return self.update_dictionary.pop(uuid, None)

    def get_update_per_agent(self, agent):
        """
        Returns the updates for a given agent
        :param agent:
        :return:
        """
        updates = self.updates_done_per_agent.pop(agent, [])
        return updates


