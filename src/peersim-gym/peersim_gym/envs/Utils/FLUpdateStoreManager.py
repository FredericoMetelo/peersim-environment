import uuid


class FLUpdateStoreManager:
    """
    This class is responsible for storing the updates generated by the different agents
    """
    def __init__(self, custom_update_size_function=None):
        self.update_dictionary = {}
        self.custom_update_size_function = custom_update_size_function

    def store_update(self, agent, src_id, dst_idx, update):
        uuid = self.generate_uuid()
        self.update_dictionary[uuid] = self.create_update_entry(uuid, agent, src_id, dst_idx, update)


    def generate_uuid(self):
        return str(uuid.uuid4())

    def create_update_entry(self, uuid, agent, src_id, dst_idx, update):
        size = self.get_update_size(update)
        return {"uuid": uuid, "agent": agent, "src_id": src_id, "dst_idx": dst_idx, "update": update, "size": size}

        def get_update_size(self, update):
        """
        This method checks what is the type of the update:
        :param update:
        :return:
        """
        if self.custom_update_size_function is not None:
            return self.custom_update_size_function(update)

        # Default strategies:
        # 1. Check if it's a pytorch full model
        # 2. Check if it's a pytorch weights
        # 3. Check if it's a pytorch gradients
        # 4. Check if it's a tensorflow full model
        # 5. Check if it's a tensorflow weights
        # 6. Check if it's a tensorflow gradients
        # TODO: Implement the size calculation for the different types of updates


