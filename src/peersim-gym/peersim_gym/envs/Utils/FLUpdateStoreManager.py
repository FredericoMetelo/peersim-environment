import uuid
from collections import OrderedDict
import math

class FLUpdateStoreManager:
    """
    This class is responsible for storing the updates generated by the different agents
    """
    def __init__(self, custom_update_size_function):
        self.update_dictionary = {}
        self.updates_done_per_agent = {}
        self.custom_update_size_function = custom_update_size_function

    def store_update(self, agent, src_id, dst_idx, update, sent_to_global, extra_info):
        uuid = self.generate_uuid()
        self.update_dictionary[uuid] = self.create_update_entry(uuid, agent, src_id, dst_idx, update, sent_to_global, extra_info)

        return self.update_dictionary[uuid]

    def generate_uuid(self):
        return str(uuid.uuid4())

    def create_update_entry(self, uuid, agent, src_id, dst_idx, update, sent_to_global, extra_info):
        size = self.get_update_size(update) # Get the size of the update in bytes
        size = math.ceil(size / 1024 / 1024) # Convert to MB
        return {"uuid": uuid, "agent": agent, "src_id": src_id, "dst_idx": dst_idx, "update": update, "size": size, "sent_to_global": sent_to_global,  "extra_info": extra_info}

    def get_update_size(self, update):
        """
        This method checks what is the type of the update:
        Supports:
        - a state_dict() of a pytorch model.
        - a list with the gradients of a pytorch model.
        - custom input, as long as a custom function to deal with it was provided.
        :param update:
        :return size:
        """
        if self.custom_update_size_function is not None:

            return self.custom_update_size_function(update)

        # Default strategies:
        if isinstance(update, OrderedDict):
            size = 0
            for key in update.keys():
                size += update[key].numel() * update[key].element_size()
            return size
        # 2. Check if it's a pytorch gradients list, only can accept lists in this mode.
        elif isinstance(update, list):
            size = 0
            for i in range(len(update)):
                size += update[i].numel() * update[i].element_size()
            return size
        else:
            raise ValueError("The update type is not supported, please use pytorch's model.state_grad(), a list of "
                             "tensors. Or provide your own custom function.")


    def set_completed(self, uuid):
        """
        Marks the update with the given uuid as completed.
        Note: I hacked it to use the same prefix everywhere, so it's only usefull if everyone has the same prefix.
        IE if agents are named "agent_0", "agent_1", "agent_2", etc. it works. If they are named "agent_0",
        "controller_1", "agent_2", etc. it doesn't work.
        :param uuid:
        :return:
        """
        update_done = self.get_update(uuid)
        if update_done is not None:
            if update_done["sent_to_global"]:
                agent = "global"
            else:
                agent_prefix = update_done["agent"].split('_')[0]
                agent_emissor = int(update_done["agent"].split('_')[1])
                agent_reciever = update_done["dst_idx"] # self.neighbourMatrix[agent_emissor][update_done["dst_idx"]]  # Changed to deal in absolute ids instead of indexes.
                agent = agent_prefix + "_" + str(agent_reciever)
            if agent in self.updates_done_per_agent:
                self.updates_done_per_agent[agent].append(update_done)
            else:
                self.updates_done_per_agent[agent] = [update_done]

    def get_update(self, uuid):
        """
        Returns the update with the given uuid and removes it from the dictionary
        :param uuid:
        :return:
        """
        return self.update_dictionary.pop(uuid, None)

    def get_update_per_agent(self, agent):
        """
        Returns the updates for a given agent
        :param agent:
        :return:
        """
        updates = self.updates_done_per_agent.pop(agent, [])
        return updates

    def passNeighbourMatrix(self, neighbourMatrix):
        self.neighbourMatrix = neighbourMatrix


