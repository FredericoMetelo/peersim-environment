import uuid
from collections import OrderedDict


class FLUpdateStoreManager:
    """
    This class is responsible for storing the updates generated by the different agents
    """
    def __init__(self, custom_update_size_function):
        self.update_dictionary = {}
        self.custom_update_size_function = custom_update_size_function

    def store_update(self, agent, src_id, dst_idx, update):
        uuid = self.generate_uuid()
        self.update_dictionary[uuid] = self.create_update_entry(uuid, agent, src_id, dst_idx, update)
        return self.update_dictionary[uuid]

    def generate_uuid(self):
        return str(uuid.uuid4())

    def create_update_entry(self, uuid, agent, src_id, dst_idx, update):
        size = self.get_update_size(update)
        return {"uuid": uuid, "agent": agent, "src_id": src_id, "dst_idx": dst_idx, "update": update, "size": size}

    def get_update_size(self, update):
        """
        This method checks what is the type of the update:
        Supports:
        - a state_dict() of a pytorch model.
        - a list with the gradients of a pytorch model.
        - custom input, as long as a custom function to deal with it was provided.
        :param update:
        :return size:
        """
        if self.custom_update_size_function is not None:

            return self.custom_update_size_function(update)

        # Default strategies:
        # 1. Check if it's a pytorch weights:
        #   They use .state_dict() to get the weights, this returns an ordered dict with a tensor per layer.
        if isinstance(update, OrderedDict):
            size = 0
            for key in update.keys():
                size += update[key].size() * update[key].element_size()
            return size
        # 2. Check if it's a pytorch gradients list, only can accept lists in this mode.
        elif isinstance(update, list):
            size = 0
            for i in range(len(update)):
                size += update[i].size() * update[i].element_size()
            return size
        else:
            raise ValueError("The update type is not supported, please use pytorch's model.state_grad(), a list of "
                             "tensors. Or provide your own custom function.")
        # 3. Check if it's a tensorflow weights
        # 4. Check if it's a tensorflow gradients
        # TODO: Implement the size calculation for the different types of updates

    def get_update(self, uuid):
        """
        Returns the update with the given uuid and removes it from the dictionary
        :param uuid:
        :return:
        """
        return self.update_dictionary.pop(uuid, None)
